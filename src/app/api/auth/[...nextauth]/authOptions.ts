import {AuthOptions, CookiesOptions} from "next-auth";
import KeycloakProvider from "next-auth/providers/keycloak";

import {SessionToken, SessionType} from "@/types/types";
import {attemptSignInToken} from "@/app/api/auth/[...nextauth]/signInToken";
import {attemptAccount} from "@/app/api/auth/[...nextauth]/account";
import {attemptSessionAccessToken} from "@/app/api/auth/[...nextauth]/sessionAccessToken";
import {jwtDecode} from "jwt-decode";
import {attemptSessionToken} from "@/app/api/auth/[...nextauth]/sessionToken";
import {refreshAccessToken} from "@/app/api/auth/[...nextauth]/refreshAccessToken";

export const authOptions: AuthOptions = {
    providers: [
        KeycloakProvider({
            clientId: `${process.env.KEYCLOAK_CLIENT_ID}`,
            clientSecret: `${process.env.KEYCLOAK_CLIENT_SECRET}`,
            issuer: `${process.env.KEYCLOAK_ISSUER}`,
        }),
    ],

    callbacks: {
        async jwt({ token, account }): Promise<SessionToken> {
            const nowTimeStamp = Math.floor(Date.now() / 1000);

            if (account) {
                const signInToken = attemptSignInToken(token);
                const accountParsed = attemptAccount(account);
                const accessTokenParsed = attemptSessionAccessToken(
                    jwtDecode(accountParsed.access_token),
                );

                return {
                    name: signInToken.name,
                    email: signInToken.email,
                    decoded: accessTokenParsed,
                    access_token: accountParsed.access_token,
                    id_token: accountParsed.id_token,
                    expires_at: accountParsed.expires_at,
                    refresh_token: accountParsed.refresh_token,
                };
            } else {
                const sessionToken = attemptSessionToken(token);

                if (nowTimeStamp < sessionToken.expires_at) {
                    return sessionToken;
                } else {
                    const refreshTokenExp = jwtDecode(sessionToken.refresh_token).exp;
                    if (refreshTokenExp && refreshTokenExp <= nowTimeStamp) {
                        return {
                            ...sessionToken,
                            refresh_token_expired: true,
                        };
                    }

                    try {
                        const { access_token, refresh_token, expires_in, id_token } =
                            await refreshAccessToken(sessionToken.refresh_token);
                        return {
                            name: sessionToken.name,
                            email: sessionToken.email,
                            access_token,
                            decoded: attemptSessionAccessToken(jwtDecode(access_token)),
                            id_token: id_token ?? sessionToken.id_token,
                            expires_at: Math.floor(Date.now() / 1000) + expires_in,
                            refresh_token,
                        };
                    } catch (error) {
                        console.error(error);
                        return {
                            ...sessionToken,
                            refresh_token_expired: true,
                        };
                    }
                }
            }
        },

        async session({ session, token }): Promise<SessionType> {
            // bypass validation here as we trust token generated by jwt callback
            const sessionToken = token as SessionToken;

            return {
                expires: session.expires,
                access_token: sessionToken.access_token,
                id_token: sessionToken.id_token,
                roles: sessionToken.decoded.realm_access?.roles,
                user: {
                    name: sessionToken.name,
                    email: sessionToken.email,
                },
                refresh_token_expired: sessionToken.refresh_token_expired,
            };
        },
    },

    cookies: cookiesOptions(),
};

/**
 * Returns pkce and state cookies options from environment variables:
 * - NEXTAUTH_PKCE_MAX_AGE pkce max age
 * - NEXTAUTH_STATE_MAX_AGE state max age
 * - NEXTAUTH_USE_SECURE_COOKIES use secure cookie, defaults to true
 */
export function cookiesOptions(): Partial<CookiesOptions> | undefined {
    const {
        pkceMaxAge,
        stateMaxAge,
        useSecureCookies = true,
    }: CookiesOptionsParams = parseCookiesOptionsParams();

    if (!pkceMaxAge && !stateMaxAge) {
        return undefined;
    }

    const cookiePrefix = useSecureCookies ? '__Secure-' : '';

    const options: Partial<CookiesOptions> = {};

    if (pkceMaxAge) {
        options.pkceCodeVerifier = {
            name: `${cookiePrefix}next-auth.pkce.code_verifier`,
            options: {
                httpOnly: true,
                sameSite: 'lax',
                path: '/',
                secure: useSecureCookies,
                maxAge: pkceMaxAge,
            },
        };
    }
    if (stateMaxAge) {
        options.state = {
            name: `${cookiePrefix}next-auth.state`,
            options: {
                httpOnly: true,
                sameSite: 'lax',
                path: '/',
                secure: useSecureCookies,
                maxAge: stateMaxAge,
            },
        };
    }

    return options;
}

function parseCookiesOptionsParams(): CookiesOptionsParams {
    return {
        pkceMaxAge: toNumber(process.env.NEXTAUTH_PKCE_MAX_AGE),
        stateMaxAge: toNumber(process.env.NEXTAUTH_STATE_MAX_AGE),
        useSecureCookies: toBoolean(process.env.NEXTAUTH_USE_SECURE_COOKIES),
    };
}

type CookiesOptionsParams = {
    pkceMaxAge: number | undefined;
    stateMaxAge: number | undefined;
    useSecureCookies: boolean | undefined;
};

function toNumber(value: string | undefined): number | undefined {
    return Number.isNaN(Number(value)) ? undefined : Number(value);
}

function toBoolean(value: string | undefined): boolean | undefined {
    switch (value && value.toLowerCase()) {
        case 'true':
            return true;
        case 'false':
            return false;
        default:
            return undefined;
    }
}